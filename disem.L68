00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/27/2017 4:12:00 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 
00000000                             3  * Written by : DANNY AND EDWARD
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7  *-CURRENT STATE ONLY CONVERTS THE STRING ADDRESS TO A HEX ADDRESS STORED INSIDE D6
00001000                             8      ORG    $1000
00001000  =0000000D                  9  CR  EQU $0D
00001000  =0000000A                 10  LF  EQU $0A
00001000  =00007000                 11  startLoc    EQU $7000
00001000                            12  START:                  ; first instruction of program
00001000                            13              ;LEA     stack,SP
00001000  43F9 000005D8             14              LEA     welcome_message,A1  PRESENT THE WELCOME MESSAGE
00001006  103C 000E                 15              MOVE.B  #14,D0
0000100A  4E4F                      16              TRAP    #15
0000100C                            17              
0000100C                            18             
0000100C                            19  *- FOR TEST RANGE FROM 996 - 9CF PUT CODES OR NOP ANYWHERE BETWEEN
0000100C                            20  
0000100C                            21  * Put program code here
0000100C                            22  *-----
0000100C                            23  *This program starts by given a starting address and an ending address disassemble
0000100C                            24  *the binary code that is at that location.
0000100C                            25  *
0000100C                            26  *
0000100C                            27  *----
0000100C                            28  
0000100C                            29  
0000100C                            30  *run_program     
0000100C                            31  *                MOVE.L  #0,A3
0000100C                            32  *                CLR     D1
0000100C                            33  *                LEA     enter_start_AD,A1
0000100C                            34  *                MOVE.L  #14,D0
0000100C                            35  *                TRAP    #15
0000100C                            36                  
0000100C                            37                  
0000100C                            38                  *---------------------I/O SECTION
0000100C                            39                  
0000100C                            40  get_input_start_addr 
0000100C  267C 00000000             41                  MOVE.L  #0,A3
00001012  4241                      42                  CLR     D1
00001014  43F9 000006C5             43                  LEA     enter_start_AD,A1
0000101A  700E                      44                  MOVE.L  #14,D0
0000101C  4E4F                      45                  TRAP    #15
0000101E                            46                  
0000101E                            47                  
0000101E                            48  
0000101E                            49        
0000101E  43F9 000006E0             50                  LEA     userStartAddrInput,A1   load address to store the input from user
00001024  7002                      51                  MOVE.L  #2,D0
00001026  4E4F                      52                  TRAP    #15
00001028  4EB9 0000052C             53                  JSR     parse_input         parse the starting address
0000102E                            54                  
0000102E                            55                  
0000102E  2A46                      56                  MOVE.L  D6,A5   MOVE OUR STARTING ADDRESS TO A6
00001030                            57                  
00001030                            58                  *----MIGHT NEED TO CHECK FOR ODD ADDRESSING ?
00001030                            59                  *----CHECK FOR ADDRESS OUT OF BOUNDS DOMAIN?
00001030                            60  
00001030                            61  
00001030                            62  get_input_end_addr
00001030  267C 00000000             63                  MOVE.L  #0,A3
00001036  4241                      64                  CLR     D1
00001038  43F9 00000744             65                  LEA     userEnd,A1
0000103E  700E                      66                  MOVE.L  #14,D0
00001040  4E4F                      67                  TRAP    #15
00001042                            68                  
00001042                            69  
00001042                            70  
00001042  43F9 00000712             71                  LEA     userEndAddrInput,A1
00001048  1239 00000744             72                  MOVE.B  userEnd,D1
0000104E  7002                      73                  MOVE.L  #2,D0
00001050  4E4F                      74                  TRAP    #15
00001052  4EB9 00000542             75                  JSR     parse_end
00001058                            76  
00001058                            77                  
00001058  2C46                      78                  MOVE.L  D6,A6   MOVE OUT ENDING ADDRESS TO A7
0000105A                            79    
0000105A                            80               
0000105A                            81  STORE_SRT_END:
0000105A                            82                 
0000105A                            83                        ;store the starting and ending address into memory out of range
0000105A  9C4D                      84              SUB.W   A5,D6   SUBTRACT THE STARTING ADDRESS FROM THE ENDING ADDRESS TO GET THE SIZE OF INSTRUCTIONS
0000105C  23CD 00FFFF00             85              MOVE.L  A5,$00FFFF00    STORE USER START ADDRESS SO WE CAN FREE UP REG
00001062  23CE 00FFFF10             86              MOVE.L  A6,$00FFFF10    STORE USER END ADDRESS SO WE CAN FREE UP REG
00001068  23C6 00FFFF20             87              MOVE.L  D6,$00FFFF20    STORE SIZE OF INSTRCTIONS
0000106E  284D                      88              MOVE.L  A5,A4
00001070  6000 0038                 89              BRA nextCode
00001074                            90              
00001074                            91     
00001074                            92  *---move_addresses:
00001074                            93                                  
00001074                            94                  *-MOVE 2 INTO DATA REG
00001074                            95                  
00001074                            96                  ;JSR     LOOP
00001074                            97                  *----LEA     good_code_buffer,a2 ;load the code buffer
00001074                            98                  *-STORE THE OLD ADDRESS/STARTING/CURRENT INTO A0
00001074                            99                  *----MOVE.W  A4,A0
00001074                           100                  
00001074                           101                  *-STORE 2 AT DATA REG MAYBE FOR INCREMNTEATION
00001074                           102                  *----MOVE.B  #2,D4
00001074                           103                  
00001074                           104                  *-MOVE OLD ADDRESS TO DATA REGISTER
00001074                           105                  *-----MOVE.L  A0,D3   ;D3 IS USED TO PRINT OUT THE ADDRESS LINE, OR ANYTHING IN D3
00001074                           106                  *------MOVE.L  D3,D7
00001074                           107                  
00001074                           108  
00001074                           109  
00001074                           110  
00001074                           111                  *------LEA     good_code_buffer,A2 load again
00001074                           112                  *------JSR     print_d3
00001074                           113                  
00001074                           114                  
00001074                           115                  ;JSR     get_opcode 
00001074                           116  
00001074                           117                  *----MIGHT NEED TO CHECK FOR ODD ADDRESSING ?
00001074                           118                  *----CHECK FOR ADDRESS OUT OF BOUNDS DOMAIN?
00001074                           119                  ;SIMHALT
00001074                           120  print_d3:
00001074  B87C 0002                121                  CMP.w   #2,d4
00001078  6600 0082                122                  BNE     printword       data is word
0000107C  4843                     123                  swap    d3              swap data to print first word
0000107E  E04B                     124                  LSR.W   #8,D3       shift to isolate first nibble
00001080  E84B                     125                  LSR.W   #4,D3
00001082                           126                  
00001082                           127                  *-print the word
00001082                           128  
00001082                           129  * ---------------------------------------------------------- 
00001082                           130  * Decode ---------------------------------------------------
00001082  49F8 7000                131              LEA     startLoc,A4 ;loads statLoc's EA into A4
00001086  6000 0022                132              BRA     nextCode    ;put data in D3, incre. A4
0000108A                           133       
0000108A                           134  mainLoop          
0000108A                           135  
0000108A  E84B                     136              LSR     #4,D3       SHIFT 4 BITS TO GET THE MSB OF THE WORD
0000108C                           137              
0000108C                           138              ;compare bits to instructions
0000108C                           139              ;CMP.B   #bin0001,D3 ;MOVE.B
0000108C                           140              ;BEQ     op0001      ;branch to op0001
0000108C                           141              ;CMP.B   #bin0011,D3 ;MOVE.W
0000108C                           142              ;BEQ     op0011      ;branch to op0011
0000108C                           143              ;CMP.B   #bin0010,D3 ;MOVE.L 
0000108C                           144              ;BEQ     op0010      ;branch to op0010           
0000108C                           145              ;CMP.B   #bin0111,D3 ;MOVEQ
0000108C                           146              ;BEQ     op0111      ;branch to op0111                        
0000108C  B63C 0004                147              CMP.B   #bin0100,D3 ;MOVEM.L, MOVEM.W, LEA, CLR, JSR, RTS
00001090  6700 01A4                148              BEQ     op0100      ;branch to op0100                        
00001094                           149              ;CMP.B   #bin1101,D3 ;ADD, ADDA
00001094                           150              ;BEQ     op1101      ;branch to op1101            
00001094                           151              ;CMP.B   #bin1001,D3 ;SUB, SUBA
00001094                           152              ;BEQ     op1001      ;branch to op1001                        
00001094                           153              ;CMP.B   #bin0000,D3 ;ADDI, ANDI, EORI, BCHG, CMPI
00001094                           154              ;BEQ     op0000      ;branch to op0000                       
00001094                           155              ;CMP.B   #bin0101,D3 ;SUBQ
00001094                           156              ;BEQ     op0101      ;branch to op0101                         
00001094                           157              ;CMP.B   #bin0110,D3 ;Bcc
00001094                           158              ;BEQ     op0110      ;branch to op0110            
00001094                           159              ;CMP.B   #bin1000,D3 ;DIVU.W
00001094                           160              ;BEQ     op1000      ;branch to op1000                                      
00001094                           161              ;CMP.B   #bin1011,D3 ;CMP, CMPA, EOR
00001094                           162              ;BEQ     op1011      ;branch to op1011 
00001094                           163              ;CMP.B   #bin1100,D3 ;AND, MULS.W
00001094                           164              ;BEQ     op1100      ;branch to op1100                                    
00001094                           165              ;CMP.B   #bin1110,D3 ;ASR, LSL, ROL, ROR
00001094                           166              ;BEQ     op1110      ;branch to op1110            
00001094                           167              
00001094  6000 01C6                168              BRA     opERROR     ;invalid opcode display
00001098                           169              
00001098                           170              ;branch to display opError display
00001098                           171              
00001098                           172              ;print all the things...
00001098                           173   *******************************************************************************
00001098                           174  *
00001098                           175  *******************************************************************************
00001098                           176  addressCount 
00001098                           177              *-THIS LOCATION IS WHERE WE WILL PERIODICALLY CHECK THE RUNNING A4 REGISTERY WITH OUR STORED
00001098                           178              *-ENDING ADDRESS VALUE TO SEE IF WE HAVE REACHED THE END OF OUR ADDRESS RANGE
00001098                           179              *-A4 IS ALSO ACTS AS OUR 'I' VALUE OR OUR VALUE THAT KEEPS POINTING TO MEMORY LOCATIONS
00001098                           180              *-OUT POINTE
00001098  4BF9 00FFFF10            181              LEA   $00FFFF10,A5  * loads ending address 
0000109E  2215                     182              MOVE.L  (A5),D1     * move value to D1
000010A0  2A0C                     183              MOVE.L  A4,D5       * move address to D5
000010A2  B285                     184              CMP.L   D5,D1       * compare current and ending address
000010A4  6F00 F42E                185              BLE     FINISH  * branch to end if ending address reached
000010A8  4E75                     186              RTS                 * return if not
000010AA                           187              
000010AA                           188  nextCode:
000010AA  4EB8 1098                189                  JSR addressCount
000010AE                           190                  *-line count
000010AE  4245                     191                  CLR D5
000010B0  45F9 00000614            192                  Lea good_code_buffer,A2 ;reset A2
000010B6  304C                     193                  MOVE.W  A4,A0   UPDATE OUR OLD ADDRESS STORED AT 10 WITH THE MOST CURRENT POINTER ADDRESS *INCRMENTED BY A WORD
000010B8  7E02                     194                  MOVE.L  #2,D7
000010BA  2608                     195                  MOVE.L  A0,D3
000010BC  2C03                     196                  MOVE.L  D3,D6
000010BE  45F9 00000614            197                  LEA     good_code_buffer,A2
000010C4  4EB9 000010E6            198                  JSR     _printdatainD3
000010CA                           199                  
000010CA  14BC 0020                200                  MOVE.B  #' ',(A2)
000010CE  14BC 0020                201                  MOVE.B  #' ',(A2)
000010D2  14BC 0020                202                  MOVE.B  #' ',(A2)
000010D6  14BC 0020                203                  MOVE.B  #' ',(A2)
000010DA                           204                  
000010DA  4286                     205                  CLR.L   D6
000010DC  4283                     206                  CLR.L   D3
000010DE                           207                  
000010DE  3C1C                     208                  MOVE.W  (A4)+,D6 INCREMENT OUT STARTING/CURRENT POINTER BY A WORD, STORE THE CONTENTS OF WHAT ITS CURRENTLY POINTING AT
000010E0                           209                                     *-WHICH WOULD BE THE OPCODE DATA, INTO D6
000010E0  3606                     210                  MOVE.W  D6,D3
000010E2  E04B                     211                  LSR.W   #8,D3
000010E4                           212                  
000010E4  60A4                     213                  BRA     mainLoop
000010E6                           214                  
000010E6                           215  _printdatainD3:
000010E6  BE7C 0002                216                  CMP.W   #2,D7
000010EA  6600 0010                217                  BNE     printword
000010EE  4843                     218                  SWAP    D3
000010F0  4846                     219                  SWAP    D6
000010F2  4EB9 000010FC            220                  JSR     printword
000010F8  4846                     221                  SWAP    D6
000010FA  2606                     222                  MOVE.L  D6,D3
000010FC                           223                  
000010FC                           224   printword:
000010FC  E04B                     225                  LSR.W   #8,D3
000010FE  E84B                     226                  LSR.W   #4,D3
00001100  C6FC 0008                227                  MULU.W  #8,D3
00001104  4DF9 00001156            228                  LEA     numTable,A6
0000110A  4EB6 3000                229                  JSR     (A6,D3)
0000110E                           230                  
0000110E  3606                     231                  MOVE.W  D6,D3   COPY DATA
00001110  E94B                     232                  LSL.W   #4,D3
00001112  E04B                     233                  LSR.W   #8,D3
00001114  E84B                     234                  LSR.W   #4,D3
00001116  C6FC 0008                235                  MULU.W  #8,D3
0000111A  4DF9 00001156            236                  LEA     numTable,A6
00001120  4EB6 3000                237                  JSR     (A6,D3)
00001124                           238                  
00001124  3606                     239                  MOVE.W  D6,D3
00001126                           240                  
00001126  E14B                     241                  LSL.W   #8,D3
00001128  E04B                     242                  LSR.W   #8,D3
0000112A  E84B                     243                  LSR.W   #4,D3
0000112C  C6FC 0008                244                  MULU.W  #8,D3
00001130  4DF9 00001156            245                  LEA numTable,A6
00001136  4EB6 3000                246                  JSR     (A6,D3)
0000113A                           247                  
0000113A                           248                  
0000113A  3606                     249                  MOVE.W  D6,D3
0000113C  E94B                     250                  LSL.W   #4,D3
0000113E  E14B                     251                  LSL.W   #8,D3
00001140  E04B                     252                  LSR.W   #8,D3
00001142  E84B                     253                  LSR.W   #4,D3
00001144  C6FC 0008                254                  MULU.W  #8,D3
00001148  4DF9 00001156            255                  LEA     numTable,A6
0000114E  4EB6 3000                256                  JSR     (A6,D3)
00001152  5805                     257                  ADDI.B  #4,D5
00001154  4E75                     258                  RTS
00001156                           259                  
00001156                           260  
00001156                           261  * -----------------------------------------------------------            
00001156                           262  * Jump Table numTable ***************************************
00001156                           263  *** prints the associated number of the register            *
00001156                           264  *** Also prints hex values for data and addresses           *
00001156                           265  *************************************************************
00001156  4EB9 000011D6            266  numTable    JSR     N0000   ;register 0
0000115C  4E75                     267              RTS             ;return, done printing
0000115E  4EB9 000011DC            268              JSR     N0001   ;register 1
00001164  4E75                     269              RTS             ;return, done printing
00001166  4EB9 000011E2            270              JSR     N0010   ;register 2
0000116C  4E75                     271              RTS             ;return, done printing
0000116E  4EB9 000011E8            272              JSR     N0011   ;register 3
00001174  4E75                     273              RTS             ;return, done printing
00001176  4EB9 000011EE            274              JSR     N0100   ;register 4
0000117C  4E75                     275              RTS             ;return, done printing
0000117E  4EB9 000011F4            276              JSR     N0101   ;register 5
00001184  4E75                     277              RTS             ;return, done printing
00001186  4EB9 000011FA            278              JSR     N0110   ;register 6
0000118C  4E75                     279              RTS             ;return, done printing
0000118E  4EB9 00001200            280              JSR     N0111   ;register 7
00001194  4E75                     281              RTS             ;return, done printing
00001196  4EB9 00001206            282              JSR     N1000   ;num 8
0000119C  4E75                     283              RTS             ;return, done printing
0000119E  4EB9 0000120C            284              JSR     N1001   ;num 9
000011A4  4E75                     285              RTS             ;return, done printing
000011A6  4EB9 00001212            286              JSR     N1010   ;num A
000011AC  4E75                     287              RTS             ;return, done printing
000011AE  4EB9 00001218            288              JSR     N1011   ;num B
000011B4  4E75                     289              RTS             ;return, done printing
000011B6  4EB9 0000121E            290              JSR     N1100   ;num C
000011BC  4E75                     291              RTS             ;return, done printing
000011BE  4EB9 00001224            292              JSR     N1101   ;num D
000011C4  4E75                     293              RTS             ;return, done printing
000011C6  4EB9 0000122A            294              JSR     N1110   ;num E
000011CC  4E75                     295              RTS             ;return, done printing
000011CE  4EB9 00001230            296              JSR     N1111   ;num F
000011D4  4E75                     297              RTS             ;return, done printing
000011D6                           298  * -----------------------------------------------------------            
000011D6                           299  * Subroutine N0000 ------------------------------------------
000011D6                           300  N0000
000011D6  14FC 0030                301              MOVE.B  #'0',(A2)+      ;display 0
000011DA  4E75                     302              RTS
000011DC                           303  
000011DC                           304  * -----------------------------------------------------------            
000011DC                           305  * Subroutine N0001 ------------------------------------------
000011DC                           306  N0001
000011DC  14FC 0031                307              MOVE.B  #'1',(A2)+      ;display 1
000011E0  4E75                     308              RTS
000011E2                           309  
000011E2                           310  * -----------------------------------------------------------            
000011E2                           311  * Subroutine N0010 ------------------------------------------
000011E2                           312  N0010
000011E2  14FC 0032                313              MOVE.B  #'2',(A2)+      ;display 2
000011E6  4E75                     314              RTS
000011E8                           315   
000011E8                           316  * -----------------------------------------------------------            
000011E8                           317  * Subroutine N0011 ------------------------------------------
000011E8                           318  N0011
000011E8  14FC 0033                319              MOVE.B  #'3',(A2)+      ;display 3
000011EC  4E75                     320              RTS
000011EE                           321  
000011EE                           322  * -----------------------------------------------------------            
000011EE                           323  * Subroutine N0100 ------------------------------------------
000011EE                           324  N0100
000011EE  14FC 0034                325              MOVE.B  #'4',(A2)+      ;display 4
000011F2  4E75                     326              RTS
000011F4                           327  
000011F4                           328  * -----------------------------------------------------------            
000011F4                           329  * Subroutine N0101 ------------------------------------------
000011F4                           330  N0101
000011F4  14FC 0035                331              MOVE.B  #'5',(A2)+      ;display 5
000011F8  4E75                     332              RTS
000011FA                           333  
000011FA                           334  * -----------------------------------------------------------            
000011FA                           335  * Subroutine N0110 ------------------------------------------
000011FA                           336  N0110
000011FA  14FC 0036                337              MOVE.B  #'6',(A2)+      ;display 6
000011FE  4E75                     338              RTS
00001200                           339              
00001200                           340  * -----------------------------------------------------------            
00001200                           341  * Subroutine N0111 ------------------------------------------
00001200                           342  N0111
00001200  14FC 0037                343              MOVE.B  #'7',(A2)+      ;display 7
00001204  4E75                     344              RTS
00001206                           345  
00001206                           346  * ----------------------------------------------------------- 
00001206                           347  * Subroutine N1000 ------------------------------------------
00001206                           348  N1000       
00001206  14FC 0038                349              MOVE.B  #'8',(A2)+      ;display 8
0000120A  4E75                     350              RTS
0000120C                           351  
0000120C                           352  * -----------------------------------------------------------            
0000120C                           353  * Subroutine N1001 ------------------------------------------
0000120C                           354  N1001   
0000120C  14FC 0039                355              MOVE.B  #'9',(A2)+      ;display 9
00001210  4E75                     356              RTS
00001212                           357  
00001212                           358  * -----------------------------------------------------------            
00001212                           359  * Subroutine N1010 ------------------------------------------
00001212                           360  N1010   
00001212  14FC 0041                361              MOVE.B  #'A',(A2)+      ;display A
00001216  4E75                     362              RTS
00001218                           363  
00001218                           364  * -----------------------------------------------------------            
00001218                           365  * Subroutine N1011 ------------------------------------------
00001218                           366  N1011   
00001218  14FC 0042                367              MOVE.B  #'B',(A2)+      ;display B
0000121C  4E75                     368              RTS
0000121E                           369  
0000121E                           370  * -----------------------------------------------------------            
0000121E                           371  * Subroutine N1100 ------------------------------------------
0000121E                           372  N1100   
0000121E  14FC 0043                373              MOVE.B  #'C',(A2)+      ;display C
00001222  4E75                     374              RTS
00001224                           375  
00001224                           376  * -----------------------------------------------------------            
00001224                           377  * Subroutine N1101 ------------------------------------------
00001224                           378  N1101   
00001224  14FC 0044                379              MOVE.B  #'D',(A2)+      ;display D
00001228  4E75                     380              RTS
0000122A                           381  
0000122A                           382  * -----------------------------------------------------------            
0000122A                           383  * Subroutine N1110 ------------------------------------------
0000122A                           384  N1110   
0000122A  14FC 0045                385              MOVE.B  #'E',(A2)+      ;display E
0000122E  4E75                     386              RTS
00001230                           387  
00001230                           388  * -----------------------------------------------------------            
00001230                           389  * Subroutine N1111 ------------------------------------------
00001230                           390  N1111   
00001230  14FC 0046                391              MOVE.B  #'F',(A2)+      ;display F
00001234  4E75                     392              RTS   
00001236                           393              
00001236                           394              
00001236                           395  op0100      ;MOVEM, LEA, CLR, JSR, RTS
00001236                           396  
00001236                           397              ;CMP.W   #$4EB9,D6   ;see if it's a JSR
00001236                           398              ;BEQ     jumpToRt            
00001236                           399              ;CMP.W   #$4E75,D6   ;see if it's a RTS
00001236                           400              ;BEQ     returnRt 
00001236                           401             
00001236                           402  * determine if contents in D3 are a word or long ---------- 
00001236                           403              ;JSR     WorL        
00001236                           404  * ---------------------------------------------------------
00001236                           405              ;CMP.B   #hex7,D3    ;see if it's a LEA
00001236                           406              ;BEQ     _lea        ;branch 
00001236                           407              
00001236                           408  * determine if contents in D3 are either CLR or MOVEM ----- 
00001236                           409              ;JSR     clrORmm       
00001236                           410  * ---------------------------------------------------------
00001236                           411              ;CMP.B   #hex8,D3    ;see if it's a CLR.B
00001236                           412              ;BEQ     _clrB       ;branch             
00001236                           413              ;CMP.B   #hex9,D3    ;see if it's a CLR.W
00001236                           414              ;BEQ     _clrW       ;branch   
00001236                           415              ;CMP.B   #hexA,D3    ;see if it's a CLR.L
00001236                           416              ;BEQ     _clrL       ;branch
00001236                           417    
00001236                           418              ;CMP.B   #hex2,D3    ;see if it's a MOVEM.W
00001236                           419              ;BEQ     _movemW     ;branch   
00001236                           420              ;CMP.B   #hex3,D3    ;see if it's a MOVEM.L
00001236                           421              ;BEQ     _movemL     ;branch              
00001236                           422                          
00001236                           423              ;BRA     opError     ;bad opcode branch to error
00001236                           424              
00001236                           425              
00001236                           426              ;CMP.W   #$4E71,D6
00001236                           427              ;BEQ     _
00001236                           428              
00001236                           429              
00001236                           430  
00001236                           431              ;Print/store JSR here
00001236  7E02                     432              MOVE.L  #2,D7       ;data is not error
00001238  14FC 0020                433              MOVE.B  #' ',(A2)+      ;print spaces
0000123C  14FC 0020                434              MOVE.B  #' ',(A2)+      ;print spaces
00001240  14FC 0020                435              MOVE.B  #' ',(A2)+      ;print spaces
00001244  14FC 0020                436              MOVE.B  #' ',(A2)+      ;print spaces
00001248  14FC 004E                437              MOVE.B  #'N',(A2)+  ;print R
0000124C  14FC 004F                438              MOVE.B  #'O',(A2)+  ;print T
00001250  14FC 0050                439              MOVE.B  #'P',(A2)+  ;print S
00001254  1A3C 0003                440              MOVE.B  #3,D5       ;counter for output
00001258  6000 0066                441              BRA     printCode
0000125C                           442              
0000125C                           443  opError                             
0000125C  2608                     444              MOVE.L  A0,D3
0000125E  2C03                     445              MOVE.L  D3,D6
00001260  45F9 0000066C            446              LEA     bad_code_buffer,A2
00001266  7E02                     447              MOVE.L  #2,D7
00001268  4EB8 10E6                448              JSR     _printdatainD3
0000126C                           449              
0000126C  14FC 0020                450              MOVE.B  #' ',(A2)+      ;print spaces
00001270  14FC 0020                451              MOVE.B  #' ',(A2)+      ;print spaces
00001274  14FC 0020                452              MOVE.B  #' ',(A2)+      ;print spaces
00001278  14FC 0020                453              MOVE.B  #' ',(A2)+      ;print spaces
0000127C  14FC 0044                454              MOVE.B  #'D',(A2)+      ;print D
00001280  14FC 0041                455              MOVE.B  #'A',(A2)+      ;print A
00001284  14FC 0054                456              MOVE.B  #'T',(A2)+      ;print T
00001288  14FC 0041                457              MOVE.B  #'A',(A2)+      ;print A
0000128C  14FC 0020                458              MOVE.B  #' ',(A2)+      ;print spaces
00001290  14FC 0020                459              MOVE.B  #' ',(A2)+      ;print spaces
00001294  14FC 0020                460              MOVE.B  #' ',(A2)+      ;print spaces
00001298  14FC 0020                461              MOVE.B  #' ',(A2)+      ;print spaces
0000129C                           462              
0000129C                           463              
0000129C  14FC 0046                464              MOVE.B  #'F',(A2)+      ;print spaces
000012A0  14FC 0046                465              MOVE.B  #'F',(A2)+      ;print spaces
000012A4  14FC 0046                466              MOVE.B  #'F',(A2)+      ;print spaces
000012A8  14FC 0046                467              MOVE.B  #'F',(A2)+      ;print spaces
000012AC                           468              
000012AC                           469              
000012AC                           470              ;MOVE.L  (A0),D3
000012AC                           471              ;MOVE.L  D3,D6
000012AC                           472              ;MOVE.L  #1,D7
000012AC                           473              ;JSR     _printdatainD3
000012AC                           474              
000012AC  14BC 0000                475              MOVE.B  #$00,(A2) * add NULL value to print string
000012B0  43F9 0000066C            476              LEA     bad_code_buffer,A1
000012B6  103C 000D                477              MOVE.B  #13,D0
000012BA  4E4F                     478              TRAP    #15   
000012BC                           479           
000012BC  6000 FDEC                480              BRA     nextCode           
000012C0                           481  printCode   
000012C0  14BC 0000                482              MOVE.B  #$00,(A2)   * add NULL value to print string
000012C4  070A 0000                483              MOVEP   (A2),D3
000012C8  43F9 00000614            484              LEA     good_code_buffer,A1 * load buffer for good code to print
000012CE  700D                     485              MOVEQ   #13,D0
000012D0  4E4F                     486              TRAP    #15         * display code
000012D2                           487    
000012D2  6000 FDD6                488              BRA     nextCode                     
000012D6                           489  * OP Codes -------------------------------------------------
000012D6  =00000000                490  bin0000     EQU     %0000   ;ADDI, ANDI, EORI, BCHG, CMPI
000012D6  =00000001                491  bin0001     EQU     %0001   ;MOVE.B
000012D6  =00000002                492  bin0010     EQU     %0010   ;MOVE.L
000012D6  =00000003                493  bin0011     EQU     %0011   ;MOVE.W
000012D6  =00000004                494  bin0100     EQU     %0100   ;MOVEM, MULS.L, DIVU.L, LEA, CLR, JSR, RTS
000012D6  =00000005                495  bin0101     EQU     %0101   ;SUBQ
000012D6  =00000006                496  bin0110     EQU     %0110   ;Bcc
000012D6  =00000007                497  bin0111     EQU     %0111   ;MOVEQ
000012D6  =00000008                498  bin1000     EQU     %1000   ;DIVU.W
000012D6  =00000009                499  bin1001     EQU     %1001   ;SUB, SUBA
000012D6  =0000000B                500  bin1011     EQU     %1011   ;CMP, CMPA, EOR
000012D6  =0000000C                501  bin1100     EQU     %1100   ;AND, MULS.W
000012D6  =0000000D                502  bin1101     EQU     %1101   ;ADD, ADDA
000012D6  =0000000E                503  bin1110     EQU     %1110   ;ASR, ASL, ROL, ROR
000012D6                           504  
000012D6                           505  
000012D6                           506              
000012D6                           507  ;LOOP:
000012D6                           508                  *-compare the adress pointers current address with ending address to see if we need to continue
000012D6                           509                  *- load the address registrer (pointer/ this helps us look at data)
000012D6                           510                  *-load address register number into data register
000012D6                           511                  
000012D6                           512                  ;MOVE.L  a5,d2   ;move the value of a5 to d2(starting/current pointing number)
000012D6                           513                  ;lea     $00FFFF10,a6    ;load the ending address to d3(we do this so in the future d3 is not just storing something, we can free up d3 to use
000012D6                           514                  ;MOVE.L  (a6),d3         since we loaded the address of ou engine value into a address register 'basically keeping its pointer instance' we deref it for the value
000012D6                           515                  ;CMP.L   d2,d3       ;if the current poiinter is the same as 
000012D6                           516                  ;BEQ     FINISH      ;finish they are equal
000012D6                           517                  ;RTS
000012D6                           518  
000012D6                           519          
000012D6                           520          *----------END OF I/O SECTION*---
000012D6                           521          *----------Start of OPCODE SUBROUTINE
000012D6  =0000A000                522  stack            EQU        $A000  
000012D6  =0000000C                523  shift            EQU        12                   * Shift 12 bits 
00000400                           524                   ORG        $400
00000400                           525           
00000400  4FF9 0000A000            526  get_opcode       LEA        stack,SP        *Load the SP
00000406  41F9 00000424            527                   LEA        jmp_table,A0    *Index into the table
0000040C  4280                     528                   CLR.L      D0              *Zero it       
0000040E  227C 00009000            529                   MOVE.L     #$00009000,A1        *We'll play with it here
00000414  3011                     530                   MOVE.W     (A1),D0
00000416  123C 000C                531                   MOVE.B     #shift,D1       *Shift 12 bits to the right  
0000041A  E268                     532                   LSR.W      D1,D0           *Move the bits
0000041C  C0FC 0006                533                   MULU       #6,D0           *Form offset     
00000420  4EB0 0000                534                   JSR        0(A0,D0)        *Jump indirect with index
00000424                           535                   
00000424  4EF9 00000484            536  jmp_table        JMP        code0000        *Bit manipulation/MOVEP/Immediate
0000042A  4EF9 00000488            537                   JMP        code0001        *MOVE.B
00000430  4EF9 0000048C            538                   JMP        code0010        *MOVE.L
00000436  4EF9 00000490            539                   JMP        code0011        *MOVE.W
0000043C  4EF9 00000494            540                   JMP        code0100        *Miscellaneous
00000442  4EF9 000004A8            541                   JMP        code0101        *ADDQ/SUBQ/Scc/DBcc
00000448  4EF9 000004AC            542                   JMP        code0110        *BSR,BRA,Bcc
0000044E  4EF9 000004B0            543                   JMP        code0111        *MOVEQ
00000454  4EF9 000004B4            544                   JMP        code1000        *OR/DIV/SBCD
0000045A  4EF9 000004B8            545                   JMP        code1001        *SUB/SUBX
00000460  4EF9 000004BC            546                   JMP        code1010        *Unassigned
00000466  4EF9 000004C0            547                   JMP        code1011        *CMP/EOR
0000046C  4EF9 000004C4            548                   JMP        code1100        *AND/MUL/ABCD/EXG
00000472  4EF9 000004C8            549                   JMP        code1101        *ADD/ADDA/ADDX
00000478  4EF9 000004CC            550                   JMP        code1110        *Shift/Rotate
0000047E  4EF9 000004D0            551                   JMP        code1111        *Special/Reserved
00000484                           552                   
00000484  4E72 2700                553  code0000         STOP       #$2700
00000488  4E72 2700                554  code0001         STOP       #$2700
0000048C  4E72 2700                555  code0010         STOP       #$2700
00000490  4E72 2700                556  code0011         STOP       #$2700
00000494  267C 00000000            557  code0100         MOVE.L     #0,A3
0000049A  4241                     558                   CLR        D1
0000049C  43F9 000006C5            559                   LEA        enter_start_AD,A1
000004A2  700E                     560                   MOVE.L     #14,D0
000004A4  4E4F                     561                   TRAP       #15
000004A6  4E75                     562                   RTS
000004A8  4E72 2700                563  code0101         STOP       #$2700
000004AC  4E72 2700                564  code0110         STOP       #$2700
000004B0  4E72 2700                565  code0111         STOP       #$2700
000004B4  4E72 2700                566  code1000         STOP       #$2700
000004B8  4E72 2700                567  code1001         STOP       #$2700
000004BC  4E72 2700                568  code1010         STOP       #$2700
000004C0  4E72 2700                569  code1011         STOP       #$2700
000004C4  4E72 2700                570  code1100         STOP       #$2700
000004C8  4E72 2700                571  code1101         STOP       #$2700
000004CC  4E72 2700                572  code1110         STOP       #$2700
000004D0  4E72 2700                573  code1111         STOP       #$2700
000004D4                           574  
000004D4                           575  FINISH:
000004D4                           576          *INCLUDE 'opcode_subroutine.x68'
000004D4  2608                     577              MOVE.L  A0,D3
000004D6  2C03                     578              MOVE.L  D3,D6
000004D8  45F9 00000614            579              LEA     good_code_buffer,A2
000004DE                           580   
000004DE                           581              
000004DE  14FC 0046                582              MOVE.B  #'F',(A2)+      ;print spaces
000004E2  14FC 0049                583              MOVE.B  #'I',(A2)+      ;print spaces
000004E6  14FC 0049                584              MOVE.B  #'I',(A2)+      ;print spaces
000004EA  14FC 004E                585              MOVE.B  #'N',(A2)+      ;print spaces
000004EE  14FC 0049                586              MOVE.B  #'I',(A2)+      ;print D
000004F2  14FC 0053                587              MOVE.B  #'S',(A2)+      ;print A
000004F6  14FC 0048                588              MOVE.B  #'H',(A2)+      ;print T
000004FA  14FC 0041                589              MOVE.B  #'A',(A2)+      ;print A
000004FE  14FC 0041                590              MOVE.B  #'A',(A2)+      ;print spaces
00000502  14FC 0041                591              MOVE.B  #'A',(A2)+      ;print spaces
00000506  14FC 0048                592              MOVE.B  #'H',(A2)+      ;print spaces
0000050A  14FC 0041                593              MOVE.B  #'A',(A2)+      ;print spaces
0000050E  14FC 0052                594              MOVE.B  #'R',(A2)+
00000512  2610                     595              MOVE.L  (A0),D3
00000514  2C03                     596              MOVE.L  D3,D6
00000516  7E01                     597              MOVE.L  #1,D7
00000518                           598  
00000518                           599              
00000518  14BC 0000                600              MOVE.B  #$00,(A2) * add NULL value to print string
0000051C  43F9 00000614            601              LEA     good_code_buffer,A1
00000522  103C 000D                602              MOVE.B  #13,D0
00000526  4E4F                     603              TRAP    #15   
00000528  FFFF FFFF                604              SIMHALT
0000052C                           605  
0000052C                           606  *-390 -> 406 WITH NOP AT 400
0000052C                           607  
0000052C                           608  
0000052C                           609  
0000052C                           610  
0000052C                           611  
0000052C                           612  
0000052C                           613  
0000052C                           614  
0000052C                           615  
0000052C                           616  
0000052C                           617  
0000052C                           618  
0000052C                           619  
0000052C                           620  
0000052C                           621  
0000052C                           622  *-Parses input - take input from user to create a memory address
0000052C                           623  *- entry is parsed to make sure it falls within a valid range
0000052C                           624  *-good inputs are converteed to hex
0000052C                           625  *-the entered addres get's stored in d3
0000052C                           626  *-
0000052C                           627  *-
0000052C                           628  
0000052C                           629  
0000052C                           630  
0000052C  7C00                     631  parse_input     MOVEQ   #$0,D6  ZERO OUT THE REGISTERY
0000052E  7A00                     632                  MOVEQ   #$0,D5  ZERO OUT THE REGISTERY
00000530                           633                  
00000530                           634                  *-CHECK TO SEE INPUT DATA
00000530  B205                     635                  CMP.B   D5,D1   D5 IS 0
00000532  6700 0086                636                  BEQ     error_no_input no input was found
00000536  0C41 0008                637                  CMPI    #$8,D1  CHECK IF THE USER ENTERED TOO MANY CHARACTERS 8+
0000053A  6E00 0090                638                  BGT     error_bad_entry
0000053E                           639                  ;BGT     error_inv_to_many_char
0000053E  6000 0018                640                  BRA     parse_each
00000542                           641  
00000542  7C00                     642  parse_end        MOVEQ   #$0,D6  CLEARS THE D6 REGISTEY
00000544  7A00                     643                  MOVEQ   #$0,D5  CLEARS D5
00000546  B205                     644                  CMP.B   D5,D1   CHECKS TO SEE IF A VALUE WAS ENTERED
00000548  6700 0070                645                  BEQ     error_no_input
0000054C  0C41 0008                646                  CMPI    #$8,D1  CHECKS IF THE USER ENTERED TOO MANY CHARACTERS 8+
00000550  6E00 007A                647                  BGT     error_bad_entry
00000554                           648                  ;BGT     error_to_many_char
00000554  6000 0002                649                  BRA     parse_each        
00000558                           650  
00000558                           651  *parse each analyzes each ind character entered
00000558                           652  *in ASCII table lower case 'f' is tyhe highest character code (102)
00000558                           653  
00000558  1419                     654  parse_each      MOVE.B  (A1)+,D2    GET THE NEXT CHARACTER FOR PARSING
0000055A  B405                     655                  CMP.B   D5,D2       CHECK IF THE NEXT VALUE IS NULL, IF SO WE HAVE EITHER ERROR OR REACHED END OF INPUT
0000055C  6700 0058                656                  BEQ     parse_complete  end of user input
00000560  B43C 0066                657                  CMP.B   #102,D2     NEED TO CHECK WETHER THE INPUT IS OUT OF ASCII RANGE 'f' is 102
00000564  6E00 0012                658                  BGT     hex_compare
00000568                           659                  
00000568                           660                  *-
00000568                           661                  *Comapare the decimal number values betyween 0 -9 first
00000568                           662                  *
00000568                           663                  *-
00000568  B43C 002F                664  dec_compare     CMP.B   #47,D2      if its lower than 47 that means its invalid character
0000056C                           665                                      *-for decimal values between [47, 57] are valid
0000056C  6F00 0056                666                  BLE     error_char 
00000570  B43C 003A                667                  CMP.B   #58, D2     IF THE VALUE IS NOT LESS THAN 47 AND NOT GREATER THAN 58 WE CAN CONVERT DECIMAL TO HEX
00000574  6D00 0022                668                  BLT     dec_convert
00000578                           669                  *-
00000578                           670                  *there are no number values, lets check alpha characters
00000578                           671                  *->IF the value is not less than 65 which is 'A' and the value is NO more than
00000578                           672                  *->71 'G' then we should go and convert to hex range A-F
00000578                           673                  *-UPPER case
00000578                           674                  *-      
00000578  B43C 0041                675  hex_compare     CMP.B   #65,D2      CHECK TO SEE IF THE VALUE OF THE CHAR IS LESS THAN 65(A)
0000057C  6D00 0046                676                  BLT     error_char  the VALUE IS LESS THAN 65 WHICH IS SYMBOLS AND INVALID
00000580  B43C 0047                677                  CMP.B   #71,D2      CHECK TO SEE IF THE VALUE OF THE CHAR IS LESS THAN 71(G)
00000584  6D00 001C                678                  BLT     upper_ascii VALUE FELL IN RANGE A-F                 
00000588  B43C 0061                679  low_hex_compare CMP.B   #97,D2      CHECK TO SEE IF VALUE IS LESS THAN 97 'a'
0000058C  6D00 0036                680                  BLT     error_char  VALUE IS SOME SYMBOL *- 97 - 103
00000590  B43C 0067                681                  CMP.B   #103,D2     CHECK IF ITS WITHIN RANGE, LESS THAN 103
00000594  6D00 0016                682                  BLT     lower_ascii
00000598                           683                  
00000598                           684           
00000598  0402 0030                685  dec_convert     SUBI.B  #48,D2      CONVERT TO HEX FROM ASCII BY SUBTRACTING 48 FROM CURRENT DECIMAL VALUE
0000059C                           686                  *-BECAUSE 0 - 9 THE HEX VALUES WILL BE A SINGLE CHAR WE SHIFT LEFT
0000059C  E986                     687                  ASL.L   #4,D6
0000059E  DC02                     688                  ADD.B   D2,D6       MOVE NEW BYTE INTO THE RETURN REGISTER
000005A0  60B6                     689                  BRA     parse_each  continue to parse the next character, SHOULD BE IN RANGE FOR LOWER
000005A2                           690                                      *- 97 - 103
000005A2                           691                  
000005A2                           692                              
000005A2                           693  *- ASCII conversions UPPER case to hex value by substracting 55
000005A2                           694  
000005A2  0402 0037                695  upper_ascii     SUBI.B  #55,D2  SUBTRACT 55 TO GET THE HEX VALUE OF THE CORRESPONDING CHARACTER
000005A6  E986                     696                  ASL.L   #4,D6   MOVE THE SANITIZED VALUE INTO D6 REGISTER
000005A8  DC02                     697                  ADD.B   D2,D6   MOVE THE NEW BYTE INTO RETURN REGISTER
000005AA  60AC                     698                  BRA     parse_each  parse next item
000005AC                           699  *-ASCI lower case to hex value by subtracting 87
000005AC  0402 0057                700  lower_ascii     SUBI.B  #87,D2
000005B0  E986                     701                  ASL.L   #4,D6
000005B2  DC02                     702                  ADD.B   D2,D6
000005B4  60A2                     703                  BRA     parse_each
000005B6                           704  
000005B6  7801                     705  parse_complete  MOVEQ   #1,D4  FINISH PARSING USER INPUT
000005B8  4E75                     706                  RTS             JUMP FROM SUBROUTINE                
000005BA  43F9 0000068A            707  error_no_input  LEA no_entry,A1 load bad entry statment
000005C0  7001                     708                  MOVE.L  #1,D0
000005C2  4E4F                     709                  TRAP    #15
000005C4                           710                  ;JMP     get_input
000005C4  43F9 000006B2            711  error_char      LEA bad_char,A1
000005CA  4E4F                     712                  trap #15
000005CC                           713                  ;JMP get_input0
000005CC  43F9 0000069D            714  error_bad_entry LEA bad_entry,A1
000005D2  4E4F                     715                  TRAP #15
000005D4                           716                  ;JMP  get_input
000005D4                           717  
000005D4                           718  
000005D4  FFFF FFFF                719      SIMHALT             ; halt simulator
000005D8                           720  
000005D8                           721  * Put variables and constants here
000005D8= 48 65 6C 6C 6F 20 ...    722  welcome_message DC.B    'Hello and Welcome 68Kkrew"s 68K Disassembler(get the pun)',CR,LF,0
00000614                           723  
00000614                           724  
00000614                           725  good_code_buffer    DS.B    88
0000066C                           726  
0000066C                           727  bad_code_buffer     DS.B    30
0000068A= 4E 6F 20 45 6E 74 ...    728  no_entry    DC.B    'No Entry detected.',0
0000069D= 42 61 64 20 45 6E ...    729  bad_entry   DC.B    'Bad Entry Dectected.',0
000006B2= 42 61 64 20 43 68 ...    730  bad_char    DC.B    'Bad Char detected.',0
000006C5                           731  *-errors
000006C5                           732  ;enter_start_AD  DC.B    'Enter a starting address between $0 and $00FFFE00: ',0
000006C5= 45 6E 74 65 72 20 ...    733  enter_start_AD  DC.B    'Enter a starting address: ',0
000006E0                           734  userStartAddrInput  DS.B    50  address used to store the data input from user
00000712                           735  userEndAddrInput    DS.B    50  address used to stoer the data input from user
00000744                           736  
00000744= 45 6E 74 65 72 20 ...    737  userEnd         DC.B    'Enter an address greater than the starting address: ',0
00000779                           738  
00000779                           739  userEndInput    DS.B    50  addresse used to store the data input from user
000007AC  43F8 068A                740  error_inv_to_many_char  LEA no_entry,A1 load bad entry statment
000007B0  7001                     741                          MOVE.L  #1,D0
000007B2  4E4F                     742                          TRAP    #15
000007B4                           743                          ;JMP     get_input
000007B4                           744  
000007B4                           745  *-i dea i could load the string "           DATA            " without the cursor and find a way to load the address at the line
000007B4                           746  
000007B4                           747      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESSCOUNT        1098
BAD_CHAR            6B2
BAD_CODE_BUFFER     66C
BAD_ENTRY           69D
BIN0000             0
BIN0001             1
BIN0010             2
BIN0011             3
BIN0100             4
BIN0101             5
BIN0110             6
BIN0111             7
BIN1000             8
BIN1001             9
BIN1011             B
BIN1100             C
BIN1101             D
BIN1110             E
CODE0000            484
CODE0001            488
CODE0010            48C
CODE0011            490
CODE0100            494
CODE0101            4A8
CODE0110            4AC
CODE0111            4B0
CODE1000            4B4
CODE1001            4B8
CODE1010            4BC
CODE1011            4C0
CODE1100            4C4
CODE1101            4C8
CODE1110            4CC
CODE1111            4D0
CR                  D
DEC_COMPARE         568
DEC_CONVERT         598
ENTER_START_AD      6C5
ERROR_BAD_ENTRY     5CC
ERROR_CHAR          5C4
ERROR_INV_TO_MANY_CHAR  7AC
ERROR_NO_INPUT      5BA
FINISH              4D4
GET_INPUT_END_ADDR  1030
GET_INPUT_START_ADDR  100C
GET_OPCODE          400
GOOD_CODE_BUFFER    614
HEX_COMPARE         578
JMP_TABLE           424
LF                  A
LOWER_ASCII         5AC
LOW_HEX_COMPARE     588
MAINLOOP            108A
N0000               11D6
N0001               11DC
N0010               11E2
N0011               11E8
N0100               11EE
N0101               11F4
N0110               11FA
N0111               1200
N1000               1206
N1001               120C
N1010               1212
N1011               1218
N1100               121E
N1101               1224
N1110               122A
N1111               1230
NEXTCODE            10AA
NO_ENTRY            68A
NUMTABLE            1156
OP0100              1236
OPERROR             125C
PARSE_COMPLETE      5B6
PARSE_EACH          558
PARSE_END           542
PARSE_INPUT         52C
PRINTCODE           12C0
PRINTWORD           10FC
PRINT_D3            1074
SHIFT               C
STACK               A000
START               1000
STARTLOC            7000
STORE_SRT_END       105A
UPPER_ASCII         5A2
USEREND             744
USERENDADDRINPUT    712
USERENDINPUT        779
USERSTARTADDRINPUT  6E0
WELCOME_MESSAGE     5D8
_PRINTDATAIND3      10E6
